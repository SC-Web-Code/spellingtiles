<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Spelling Suite</title>
<style>
  :root{
    --glass-bg: rgba(255,255,255,.14);
    --glass-brd: rgba(255,255,255,.22);
    --glass-sh: 0 10px 40px rgba(0,0,0,.24);
    --text:#0b1220;

    --brand-grad: linear-gradient(90deg, #22d3ee, #a78bfa, #f472b6);
    --pill:#ffffffaa; --pill-brd:#ffffff88;
    --btn:#ffffffcc; --btn-brd:#ffffff88;

    --slot-bg:#ffffff77;  /* crossword slots */
    --given-bg:#d1fae5;   /* prefilled cells (incl. colour bridges) */

    --ok:#10b981; --bad:#ef4444;
  }

  html,body{height:100%;margin:0;font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;color:var(--text)}
  body{
    background:
      radial-gradient(1200px 800px at 10% 10%, #ffedd5, transparent 60%),
      radial-gradient(900px 700px at 85% 15%, #dbeafe, transparent 60%),
      radial-gradient(900px 700px at 20% 85%, #fce7f3, transparent 60%),
      linear-gradient(120deg, #22d3ee 0%, #a78bfa 45%, #f472b6 100%);
    background-size:140% 140%; animation:bgMove 18s ease-in-out infinite alternate;
    display:flex; justify-content:center; padding:min(28px,5vw);
  }
  @keyframes bgMove{0%{background-position:0% 40%}100%{background-position:100% 60%}}

  .wrap{ width:min(1200px,96vw); }
  .hidden{ display:none !important; }

  /* HERO TITLE */
  .titleHero{display:flex;justify-content:center;gap:10px;flex-wrap:wrap;margin:6px 0 14px}

  /* ---------- DISPLAY TILE BASE (made ~2 font sizes smaller) ---------- */
  .tile{
    user-select:none;
    width:clamp(36px, 7.5vw, 46px);
    height:clamp(36px, 7.5vw, 46px);
    display:flex; align-items:center; justify-content:center;
    border:3px solid #ffffffaa; border-radius:10px; font-weight:1000;
    font-size:clamp(16px, 5vw, 22px);
    letter-spacing:.4px; box-shadow:0 12px 22px rgba(0,0,0,.18); color:#0b1220;
    background:linear-gradient(180deg,#fff,#f3e8ff);
  }
  .tile.titleTile{
    width:clamp(46px,7.5vw,66px);
    height:clamp(46px,7.5vw,66px);
    border-radius:14px;
    font-size:clamp(22px,4.8vw,34px);
    box-shadow:0 14px 26px rgba(0,0,0,.22);
  }
  .tile.chipTile{ /* Theme button size */
    width:clamp(22px,4vw,28px);
    height:clamp(22px,4vw,28px);
    border-radius:8px;
    font-size:clamp(12px,3.2vw,16px);
    box-shadow:0 8px 16px rgba(0,0,0,.18);
  }
  .tile.uiLabel{ /* small (for CORRECT / COMPLETE / %) */
    width:clamp(14px, 1.8vw, 20px);
    height:clamp(14px, 1.8vw, 20px);
    border-radius:6px;
    font-size:clamp(10px, 1.2vw, 12px);
    box-shadow:0 5px 10px rgba(0,0,0,.12);
  }

  /* Slightly larger small tiles inside Spelling Test feedback/summary */
  #st .st-result .tile.uiLabel,
  #st #st-summary .tile.uiLabel{
    width: clamp(24px, 2.6vw, 26px);
    height: clamp(24px, 2.6vw, 26px);
    font-size: clamp(16px, 1.6vw, 18px);
  }

  .inlineTiles{ display:flex; justify-content:center; gap:6px; flex-wrap:wrap; }

  .card{ position:relative; border-radius:28px; padding:clamp(18px,3vw,32px);
    backdrop-filter: blur(14px) saturate(130%); background: var(--glass-bg);
    border:1px solid var(--glass-brd); box-shadow:var(--glass-sh); overflow:hidden; }
  .blob{ position:absolute; filter:blur(50px); opacity:.45; pointer-events:none;}
  .blob.b1{width:300px;height:300px;background:#fecaca;top:-80px;left:-60px;border-radius:50%}
  .blob.b2{width:360px;height:360px;background:#bfdbfe;bottom:-90px;right:-80px;border-radius:50%}
  .blob.b3{width:260px;height:260px;background:#f5d0fe;top:40%;left:-70px;border-radius:50%}

  .subtitle{margin:10px 0 16px;color:#0b1220cc;font-weight:600;font-size:clamp(14px,2.6vw,16px)}

  .controls{display:flex;align-items:center;flex-wrap:wrap;gap:10px;margin:8px 0}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:999px;background:var(--pill);border:1px solid var(--pill-brd);font-weight:900}
  .pill.brand{
    background:var(--brand-grad); color:#fff; border:none;
    max-width: clamp(90px, 22vw, 160px); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  }

  button{appearance:none;border:none;cursor:pointer;padding:10px 12px;border-radius:14px;font-weight:900;
    font-size:clamp(13px,3.4vw,15px);letter-spacing:.3px;color:#0b1220;background:var(--btn);border:2px solid var(--btn-brd);
    transition:transform .06s ease, box-shadow .25s ease, background .2s ease; backdrop-filter: blur(6px); touch-action: manipulation;}
  button:hover{box-shadow:0 10px 18px rgba(0,0,0,.18)}
  button:active{transform:translateY(1px)}
  button:disabled{opacity:.6;cursor:not-allowed}
  .accent{color:white;border:0;background:linear-gradient(180deg,#a78bfa,#7c3aed);box-shadow:0 8px 18px rgba(124,58,237,.35)}

  textarea{width:100%;min-height:130px;resize:vertical;font-size:16px;font-weight:600;background:#ffffffc9;border:2px dashed #ffffffaa;color:#0b1220;border-radius:16px;padding:12px; box-sizing:border-box;}

  /* layout */
  .row-top{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  .two-col{display:grid;grid-template-columns:1fr;gap:16px;align-items:start}
  @media(min-width:1000px){ .two-col{grid-template-columns:minmax(340px,1.1fr) minmax(300px,.9fr);} }

  /* gameplay tiles */
  .tile.dragging{opacity:.92; transform:scale(1.08) rotate(1.2deg); box-shadow:0 16px 26px rgba(0,0,0,.28); filter:saturate(1.2)}

  /* Spelling Tiles sizing */
  #st{ --st-size: 64px; --st-min: 22px; --st-max: 72px; }
  .slots, .pool{ display:flex; gap:min(12px,2.8vw); min-height:80px; justify-content:center; }
  .slots{ flex-wrap:nowrap; overflow-x:auto; }
  .slot{
    width: var(--st-size); height: var(--st-size);
    border:3px dashed #ffffffbb; background:#ffffff22; border-radius:18px; display:flex; align-items:center; justify-content:center;
    font-size: calc(var(--st-size)*0.6); transition: transform .12s ease, background .2s ease, border-color .2s ease; }
  .slot.drop-ok{ border-color:#22d3ee; background:#ffffff55; transform:scale(1.05); }
  .slot.filled{ border-style:solid; border-color:#ffffff; background:#ffffffbb; }

  /* IMPORTANT: scope big tile sizing only to gameplay tiles (slots/pool) */
  #st .slots .tile,
  #st .pool .tile{
    width: var(--st-size);
    height: var(--st-size);
    font-size: calc(var(--st-size)*0.6);
    border-radius:18px;
  }

  .st-result{ text-align:center; font-weight:1000; min-height:34px; }
  .ok{color:var(--ok)} .bad{color:var(--bad)}
  .drag-ghost{ position:fixed; z-index:9999; pointer-events:none; }

  /* Crossword */
  .boardWrap{display:grid;place-items:center;overflow:auto}
  .board{display:grid;gap:6px;background:#ffffff66;padding:12px;border-radius:16px}
  .cell{width:clamp(38px,8vw,48px);height:clamp(38px,8vw,48px);display:flex;align-items:center;justify-content:center;
    border:3px solid #fff;border-radius:10px;font-weight:1000;font-size:clamp(18px,5.6vw,24px);background:#ffffffaa; position:relative; }
  .cell.block{background:transparent;border:none}
  .cell.given{background:var(--given-bg)}
  .cell.slot{border-style:dashed; background:var(--slot-bg)}
  .cell.slot.drop-ok{border-color:#22d3ee;background:#ffffffaa;transform:scale(1.04)}
  .cw-pool{display:flex;flex-wrap:wrap;gap:10px;justify-content:center}

  /* Lock crossword tile visuals (unchanged from gameplay scale) */
  #cw .pool .tile,
  #cw .board .tile{
    width:clamp(38px,8vw,48px);
    height:clamp(38px,8vw,48px);
    font-size:clamp(18px,5.6vw,24px);
    border-radius:10px;
  }

  .checklist{ background:#ffffff88; border:1px solid #ffffffcc; border-radius:16px; padding:12px; backdrop-filter: blur(6px); }
  .wordItem{ display:flex; align-items:center; gap:8px; padding:8px 10px; border-radius:12px; background:#ffffffc9; border:1px solid #ffffff; font-weight:900; margin-bottom:8px }
  .wordItem .mark{ width:22px; height:22px; display:grid; place-items:center; border-radius:999px; border:2px solid #93c5fd; font-size:14px }
  .wordItem.done{ background:#d1fae5; border-color:#bbf7d0 }
  .wordItem.done .mark{ border-color:#10b981; background:#10b981; color:#fff }

/* Bigger tiles for the section chip (Setup / Spelling Test / Crossword) */
#sectionChip .tile.uiLabel{
  width: clamp(20px, 2.6vw, 28px);
  height: clamp(20px, 2.6vw, 28px);
  font-size: clamp(13px, 1.9vw, 16px);
}


/* Crossword: spacing around the "WORD LIST" heading */
#cw-wordlist-title{
  margin-block: 6px; /* top & bottom */
}

/* Crossword: spacing for the feedback line ("WELL  DONE") */
#cw .st-result{
  margin: 8px 0;      /* ensure it doesn’t butt against neighbors */
}
#cw .st-result .inlineTiles{
  margin: 4px 0;      /* extra cushion for the chip-tile row itself */
}

</style>
</head>
<body>
  <div class="wrap">
    <!-- HERO TITLE -->
    <div id="heroTitle" class="titleHero" aria-label="Spelling Tiles"></div>

    <div class="card">
      <div class="blob b1"></div><div class="blob b2"></div><div class="blob b3"></div>

      <div class="row-top">
        <span id="sectionChip" class="pill" aria-live="polite"></span>
        <div class="controls" style="margin:0">
          <span class="pill brand" id="themePill"><span id="themeName">Candy</span></span>
          <button id="themeBtn" aria-label="Theme"></button>
        </div>
      </div>

      <p class="subtitle">Step 1: Spelling Test. Step 2: Build a Crossword from the same list (with a max word cap).</p>

      <!-- SETUP -->
      <div id="setup">
        <div class="two-col">
          <div>
            <p class="pill" style="display:block">Paste words (one per line or comma-separated):</p>
            <textarea id="inputWords" placeholder="cat
purple
friend
because
elephant"></textarea>
            <div class="controls">
              <button id="startSpellingBtn" class="accent">START</button>
              <button id="buildCrosswordBtn">CROSSWORD</button>
            </div>
          </div>

          <div>
            <div class="pill" style="display:block">Crossword options</div>
            <div class="controls">
              <label class="pill" style="gap:6px">Max words:
                <input id="crossCap" type="number" min="3" max="30" value="12" style="width:84px;padding:6px 8px;border-radius:10px;border:1px solid var(--pill-brd)">
              </label>
            </div>
            <div class="controls">
              <span class="pill">Prefilled letters:
                <strong id="cluePctLabel">30%</strong>
              </span>
              <input id="cluePct" type="range" min="0" max="80" value="30" style="accent-color:#8b5cf6; width:220px">
            </div>
          </div>
        </div>
      </div>

      <!-- SPELLING TEST -->
      <div id="st" style="display:none">
        <div class="row-top">
          <p class="subtitle st-subtitle">Drag or tap tiles into the slots to spell each word.</p>
          <span class="pill" id="st-progress">Word 1 of 1</span>
        </div>

        <div class="controls">
          <button id="st-reshuffleBtn">RESHUFFLE</button>
          <button id="st-skipBtn">SKIP</button>
          <span class="pill" id="st-previewPill" style="display:none;">👀 Memorise: 5</span>
          <span class="pill" id="st-score">⭐ Score: 0</span>
        </div>

        <div class="two-col" style="align-items:start">
          <div>
            <div class="subtitle" id="st-prompt">Place the tiles on the slots in the right order.</div>
            <div class="slots" id="st-slots"></div>
            <div class="pool" id="st-pool"></div>
            <div class="st-result" id="st-feedback"></div>
          </div>

          <div id="st-summary" style="display:none">
            <!-- small tiles (uiLabel) -->
            <div id="st-completeText" class="inlineTiles" aria-live="polite"></div>
            <p id="st-final" style="margin-top:8px;"></p>
            <div id="st-percentText" class="inlineTiles" aria-live="polite"></div>
            <div class="controls" style="flex-direction:column;align-items:flex-start; margin-top:8px">
              <div class="controls">
                <label class="pill" style="gap:6px">Use:
                  <select id="afterUseMode" style="padding:6px 8px;border-radius:10px;border:1px solid var(--pill-brd)">
                    <option value="all">All words</option>
                    <option value="correct">Only correct words</option>
                  </select>
                </label>
                <label class="pill" style="gap:6px">Max words:
                  <input id="afterCap" type="number" min="3" max="30" value="12" style="width:84px;padding:6px 8px;border-radius:10px;border:1px solid var(--pill-brd)">
                </label>
              </div>
              <div class="controls">
                <button id="st-buildCrosswordFromHere" class="accent">Build Crossword</button>
                <button id="st-editBtn">EDIT</button>
                <button id="st-retryBtn">RETRY</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- CROSSWORD -->
      <div id="cw" style="display:none">
        <div class="row-top">
          <p class="subtitle">Drag or tap letters into the grid. Each finished word ticks off on the right.</p>
          <span class="pill" id="cw-progress">Completed: 0 / 0</span>
        </div>

        <div class="controls" style="justify-content:space-between">
          <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
            <button id="cw-reshuffleBtn">Reshuffle</button>
          </div>
          <div>
            <button id="cw-backToSetup">BACK</button>
          </div>
        </div>

        <div class="two-col">
          <div class="boardWrap"><div id="cw-board" class="board"></div></div>
          <div class="checklist">
            <div id="cw-wordlist-title" class="inlineTiles" aria-label="Word List"></div>
            <div id="cw-listUI"></div>
          </div>
        </div>

        <div class="cw-pool" id="cw-pool"></div>
        <div class="st-result" id="cw-feedback"></div>
      </div>

    </div>
  </div>

<script>
/* ---------- tiny polyfill ---------- */
if (!window.CSS || !CSS.escape) {
  window.CSS = window.CSS || {};
  CSS.escape = CSS.escape || function (v) { return String(v).replace(/[^a-zA-Z0-9_\\-]/g, '\\\\$&'); };
}

/* ---------- colorful tile helpers ---------- */
function uiHue(i,total){ return Math.round((i*(360/Math.max(total,1)))%360); }
function makeUITile(letter, i, total, cls){
  const t=document.createElement('div');
  t.className = 'tile ' + (cls||'');
  t.textContent = letter;
  const h=uiHue(i,total);
  t.style.background = `linear-gradient(180deg, hsla(${h}, 90%, 85%, .95), hsla(${h}, 95%, 75%, .95))`;
  t.style.borderColor = `hsla(${h}, 95%, 92%, .9)`;
  return t;
}
function renderTiles(container, text, tileClass){
  container.innerHTML='';
  const chars = text.toUpperCase().split('');
  const total = chars.filter(ch=>ch!==' ').length;
  let idx=0;
  for (const ch of chars){
    if (ch===' '){
      const gap=document.createElement('div'); gap.style.width='10px'; gap.style.height='1px';
      container.appendChild(gap); continue;
    }
    container.appendChild(makeUITile(ch, idx++, total, tileClass));
  }
}
function renderTitle(container, text, tileClass){ container.classList.add('inlineTiles'); renderTiles(container, text, tileClass); }
function setButtonTileLabel(btn, text, sizeClass='chipTile'){
  btn.innerHTML='';
  const span=document.createElement('span');
  span.className='inlineTiles';
  renderTiles(span, text, sizeClass);
  btn.appendChild(span);
  btn.setAttribute('aria-label', text);
}

/* ---------- THEMES ---------- */
const themes = [
  { name:"Candy", bg:"linear-gradient(120deg,#22d3ee 0%,#a78bfa 45%,#f472b6 100%)",
    brand:"linear-gradient(90deg,#22d3ee,#a78bfa,#f472b6)",
    pill:"#ffffffaa", pillBrd:"#ffffff88", btn:"#ffffffcc", btnBrd:"#ffffff88",
    slot:"#ffffff77", given:"#d1fae5" },
  { name:"Ocean", bg:"linear-gradient(120deg,#06b6d4 0%,#3b82f6 50%,#22c55e 100%)",
    brand:"linear-gradient(90deg,#06b6d4,#3b82f6,#22c55e)",
    pill:"#e0f2fecc", pillBrd:"#bae6fd", btn:"#e0f2fe", btnBrd:"#93c5fd",
    slot:"#e0f2fe88", given:"#d1fae5" },
  { name:"Sunset", bg:"linear-gradient(120deg,#fb923c 0%,#f43f5e 50%,#8b5cf6 100%)",
    brand:"linear-gradient(90deg,#fb923c,#f43f5e,#8b5cf6)",
    pill:"#fff1e6cc", pillBrd:"#ffd9c9", btn:"#ffe4e6", btnBrd:"#fecaca",
    slot:"#ffe4e688", given:"#fde68a" },
  { name:"Forest", bg:"linear-gradient(120deg,#22c55e 0%,#16a34a 50%,#0ea5e9 100%)",
    brand:"linear-gradient(90deg,#22c55e,#16a34a,#0ea5e9)",
    pill:"#dcfce7cc", pillBrd:"#bbf7d0", btn:"#dcfce7", btnBrd:"#86efac",
    slot:"#dcfce788", given:"#bbf7d0" },
  { name:"Lemonade", bg:"linear-gradient(120deg,#fde047 0%,#facc15 50%,#f97316 100%)",
    brand:"linear-gradient(90deg,#fde047,#facc15,#f97316)",
    pill:"#fef9c3cc", pillBrd:"#fef08a", btn:"#fef9c3", btnBrd:"#fde047",
    slot:"#fef9c388", given:"#fde68a" }
];
let themeIndex = 0;
const themeBtn = document.getElementById('themeBtn');
const themeName = document.getElementById('themeName');
const themePill = document.getElementById('themePill');
function applyTheme(t){
  document.body.style.backgroundImage =
    `radial-gradient(1200px 800px at 10% 10%, #ffffff33, transparent 60%),`+
    `radial-gradient(900px 700px at 85% 15%, #ffffff22, transparent 60%),`+
    `radial-gradient(900px 700px at 20% 85%, #ffffff22, transparent 60%),`+ t.bg;
  document.documentElement.style.setProperty('--brand-grad', t.brand);
  document.documentElement.style.setProperty('--pill', t.pill);
  document.documentElement.style.setProperty('--pill-brd', t.pillBrd);
  document.documentElement.style.setProperty('--btn', t.btn);
  document.documentElement.style.setProperty('--btn-brd', t.btnBrd);
  document.documentElement.style.setProperty('--slot-bg', t.slot);
  document.documentElement.style.setProperty('--given-bg', t.given);
  themeName.textContent = t.name;
  themePill.style.background = t.brand;
}
themeBtn.addEventListener('click', ()=>{ themeIndex=(themeIndex+1)%themes.length; applyTheme(themes[themeIndex]); });
applyTheme(themes[themeIndex]);
setButtonTileLabel(themeBtn, 'Theme', 'chipTile'); // Theme (chipTile size)

/* ---------- hero + section chip ---------- */
renderTitle(document.getElementById('heroTitle'), 'Spelling Tiles', 'titleTile'); // big header
const sectionChip = document.getElementById('sectionChip');
function setSectionLabel(text){
  sectionChip.innerHTML='';
  const span=document.createElement('span'); span.className='inlineTiles';
  renderTiles(span, text, 'uiLabel'); // small tiles for section chip
  sectionChip.appendChild(span);
}

/* ---------- helpers ---------- */
const inputWords = document.getElementById('inputWords');
const startSpellingBtn = document.getElementById('startSpellingBtn');
const buildCrosswordBtn = document.getElementById('buildCrosswordBtn');

const crossCap = document.getElementById('crossCap');
const cluePct = document.getElementById('cluePct');
const cluePctLabel = document.getElementById('cluePctLabel');
cluePct.addEventListener('input',()=> cluePctLabel.textContent = cluePct.value + '%');

function parseWords(raw){
  return raw.split(/[\n,]+/).map(w=>w.trim()).filter(Boolean).map(w=>w.replace(/\s+/g,''));
}
function pickCap(words, cap){  /* always random now */
  const uniq = Array.from(new Set(words.map(w=>w.trim()).filter(Boolean)));
  if (cap >= uniq.length) return uniq;
  const arr = uniq.slice();
  for (let i=arr.length-1; i>0; i--){ const j = Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  return arr.slice(0, cap);
}

/* =======================================================================
   SPELLING TEST
   ======================================================================= */
const st = {
  root: document.getElementById('st'),
  slots: document.getElementById('st-slots'),
  pool: document.getElementById('st-pool'),
  feedback: document.getElementById('st-feedback'),
  progress: document.getElementById('st-progress'),
  scorePill: document.getElementById('st-score'),
  reshuffleBtn: document.getElementById('st-reshuffleBtn'),
  skipBtn: document.getElementById('st-skipBtn'),
  previewPill: document.getElementById('st-previewPill'),
  summary: document.getElementById('st-summary'),
  final: document.getElementById('st-final'),
  percentText: document.getElementById('st-percentText'),
  completeText: document.getElementById('st-completeText'),
  buildCWHere: document.getElementById('st-buildCrosswordFromHere'),
  editBtn: document.getElementById('st-editBtn'),
  retryBtn: document.getElementById('st-retryBtn'),
  afterUseMode: document.getElementById('afterUseMode'),
  afterCap: document.getElementById('afterCap'),
  prompt: document.getElementById('st-prompt'),
};
const PREVIEW_SECONDS = 5;
let stWords=[], stIndex=0, stScore=0, stPreviewing=false, stTilesOriginal=[], stSelected=null;
let stSolved = new Set();

function stUpdatePills(){
  st.progress.textContent = `Word ${Math.min(stIndex+1, stWords.length)} of ${stWords.length}`;
  st.scorePill.textContent = `⭐ Score: ${stScore}`;
}
function stClearStage(){ st.slots.innerHTML=''; st.pool.innerHTML=''; st.feedback.textContent=''; st.feedback.className='st-result'; stSelected=null; }
function stDerange(arr){ const a=arr.slice(); if(a.length<2) return a; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function stHue(i,total){ return Math.round((i*(360/Math.max(total,1)))%360); }
let stCurrentDragTile=null;

function stMakeTile(obj){
  const t = document.createElement('div');
  t.className='tile'; t.textContent=obj.ch.toUpperCase();
  t.setAttribute('draggable','true');
  t.dataset.tileId=obj.id; t.dataset.letter=obj.ch.toUpperCase();
  const h = stHue(obj.index??0, obj.total??8);
  t.style.background = `linear-gradient(180deg, hsla(${h}, 90%, 85%, .95), hsla(${h}, 95%, 75%, .95))`;
  t.style.borderColor = `hsla(${h}, 95%, 92%, .9)`;

  t.addEventListener('dragstart', e=>{
    t.classList.add('dragging'); stCurrentDragTile = t;
    try { e.dataTransfer.setData('text/plain', obj.id); } catch(_) {}
    try { e.dataTransfer.setData('text/tile-id', obj.id); } catch(_) {}
    e.dataTransfer.effectAllowed='move';
  });
  t.addEventListener('dragend', ()=>{ t.classList.remove('dragging'); stCurrentDragTile=null; });

  t.addEventListener('click', ()=>{ if(stPreviewing) return; if(stSelected===t){ t.classList.remove('dragging'); stSelected=null; return;} if(stSelected) stSelected.classList.remove('dragging'); stSelected=t; t.classList.add('dragging'); });

  t.addEventListener('pointerdown', e=>{
    if (e.pointerType==='mouse') return; if (stPreviewing) return; e.preventDefault(); stStartTouchDrag(t, e);
  });
  return t;
}
let stDrag=null;
function stStartTouchDrag(tile, e){
  const rect = tile.getBoundingClientRect();
  const ghost = tile.cloneNode(true);
  ghost.classList.add('drag-ghost','dragging');
  ghost.style.width=rect.width+'px'; ghost.style.height=rect.height+'px';
  ghost.style.position='fixed'; ghost.style.zIndex='9999'; ghost.style.pointerEvents='none';
  document.body.appendChild(ghost);
  st.pool.appendChild(tile);
  stDrag={node:tile, ghost, offsetX:e.clientX-rect.left, offsetY:e.clientY-rect.top, lastTarget:null};
  stUpdateGhost(e.clientX,e.clientY);
  function move(ev){ ev.preventDefault(); stUpdateGhost(ev.clientX,ev.clientY); stHighlightDrop(ev.clientX,ev.clientY); }
  function up(ev){ ev.preventDefault(); stFinishTouch(ev.clientX,ev.clientY); cleanup(); }
  function cancel(){ stCancelTouch(); cleanup(); }
  function cleanup(){ document.removeEventListener('pointermove', move, {passive:false}); document.removeEventListener('pointerup', up, {passive:false}); document.removeEventListener('pointercancel', cancel); }
  document.addEventListener('pointermove', move, {passive:false});
  document.addEventListener('pointerup', up, {passive:false});
  document.addEventListener('pointercancel', cancel);
}
function stUpdateGhost(x,y){ if(!stDrag) return; stDrag.ghost.style.left=(x-stDrag.offsetX)+'px'; stDrag.ghost.style.top=(y-stDrag.offsetY)+'px'; }
function stIsSlot(el){ return el && el.classList && el.classList.contains('slot'); }
function stFindDropContainerAt(x,y){
  let el=document.elementFromPoint(x,y);
  while (el && !stIsSlot(el) && el !== st.pool && el !== document.body) el=el.parentElement;
  return stIsSlot(el)?el:(el===st.pool?st.pool:null);
}
function stHighlightDrop(x,y){
  if(!stDrag) return;
  const target = stFindDropContainerAt(x,y);
  if (stDrag.lastTarget && stDrag.lastTarget.classList) stDrag.lastTarget.classList.remove('drop-ok');
  if (stIsSlot(target)) target.classList.add('drop-ok');
  stDrag.lastTarget=target;
}
function stFinishTouchDragTo(target){
  if (stIsSlot(target)) {
    if (target.firstElementChild) st.pool.appendChild(target.firstElementChild);
    target.appendChild(stDrag.node);
  } else {
    st.pool.appendChild(stDrag.node);
  }
}
function stFinishTouch(x,y){
  if(!stDrag) return;
  const target = stFindDropContainerAt(x,y);
  if (stDrag.lastTarget && stDrag.lastTarget.classList) stDrag.lastTarget.classList.remove('drop-ok');
  stDrag.ghost.remove();
  stFinishTouchDragTo(target||st.pool);
  stMarkFilled();
  const word = stWords[stIndex]; stCheckSolved(word);
  stDrag=null;
}
function stCancelTouch(){ if(!stDrag) return; stDrag.ghost.remove(); st.pool.appendChild(stDrag.node); stDrag=null; }

/* auto tile sizing per word */
function stFitTileSizeForWord(n){
  const container = st.slots;
  const styles = getComputedStyle(container);
  const gap = parseFloat(styles.columnGap || styles.gap || '12') || 12;
  const W = Math.max(container.clientWidth, 0);
  if (!W || n<=0){ container.style.removeProperty('--st-size'); return; }
  const minSize = parseFloat(getComputedStyle(document.getElementById('st')).getPropertyValue('--st-min')) || 22;
  const maxSize = parseFloat(getComputedStyle(document.getElementById('st')).getPropertyValue('--st-max')) || 72;
  const size = Math.max(minSize, Math.min(maxSize, Math.floor((W - gap*(n-1)) / n)));
  container.style.setProperty('--st-size', size + 'px');
}

function stBuildWord(word){
  stClearStage();

  [...word].forEach((ch,i)=>{
    const slot=document.createElement('div');
    slot.className='slot'; slot.dataset.index=String(i); slot.dataset.letter=ch.toUpperCase();
    slot.addEventListener('dragover', e=>{ e.preventDefault(); slot.classList.add('drop-ok'); });
    slot.addEventListener('dragleave', ()=> slot.classList.remove('drop-ok'));
    slot.addEventListener('drop', e=> stOnDrop(e, slot));
    slot.addEventListener('click', ()=>{
      if (stPreviewing) return;
      if (!stSelected){ if (slot.firstElementChild){ st.pool.appendChild(slot.firstElementChild); stMarkFilled(); stCheckSolved(word);} return; }
      if (slot.firstElementChild) st.pool.appendChild(slot.firstElementChild);
      slot.appendChild(stSelected); stSelected.classList.remove('dragging'); stSelected=null; stMarkFilled(); stCheckSolved(word);
    });
    st.slots.appendChild(slot);
  });

  stFitTileSizeForWord(word.length);
  const onResize = ()=> stFitTileSizeForWord(stWords[stIndex]?.length || 0);
  window.addEventListener('resize', onResize, {passive:true});
  st._removeRefit && st._removeRefit();
  st._removeRefit = ()=> window.removeEventListener('resize', onResize);

  stTilesOriginal = [...word].map((ch, idx) => ({ id:`${ch}-${idx}-${crypto.getRandomValues(new Uint32Array(1))[0]}`, ch, index:idx, total:word.length }));
  stPreviewing=true; stSetBtnsDisabled(true);
  stTilesOriginal.forEach((t,i)=>{ const el=stMakeTile(t); el.setAttribute('draggable','false'); st.slots.children[i].appendChild(el); });
  stMarkFilled();
  let sec=PREVIEW_SECONDS; st.previewPill.style.display=''; st.previewPill.textContent=`👀 Memorise: ${sec}`;
  const timer=setInterval(()=>{
    sec--; st.previewPill.textContent=`👀 Memorise: ${sec}`;
    if (sec<=0){
      clearInterval(timer);
      [...st.slots.querySelectorAll('.tile')].forEach(t=>t.classList.add('fade-out'));
      setTimeout(()=>{
        const der=stDerange(stTilesOriginal);
        [...st.slots.querySelectorAll('.tile')].forEach(t=>st.pool.appendChild(t));
        st.pool.innerHTML='';
        der.forEach((t,i)=> st.pool.appendChild(stMakeTile({...t,index:i,total:der.length})));
        stSetTilesDraggable(true); stMarkFilled(); st.previewPill.style.display='none'; stPreviewing=false; stSetBtnsDisabled(false);
        st.feedback.textContent=''; st.feedback.classList.remove('ok','bad');
      },200);
    }
  },1000);

  st.pool.addEventListener('dragover', e=>{ e.preventDefault(); });
  st.pool.addEventListener('drop', (e)=>{
    e.preventDefault();
    const id = e.dataTransfer.getData('text/tile-id') || e.dataTransfer.getData('text/plain');
    const existing = id ? document.querySelector(`[data-tile-id="${CSS.escape(id)}"]`) : stCurrentDragTile;
    if (existing){ st.pool.appendChild(existing); stMarkFilled(); stCheckSolved(word); }
  });
}
function stOnDrop(e, slot){
  e.preventDefault(); slot.classList.remove('drop-ok');
  const id=e.dataTransfer.getData('text/tile-id') || e.dataTransfer.getData('text/plain');
  let tile = id ? document.querySelector(`[data-tile-id="${CSS.escape(id)}"]`) : stCurrentDragTile;
  if(!tile) return;
  if (slot.firstElementChild) st.pool.appendChild(slot.firstElementChild);
  slot.appendChild(tile); stMarkFilled(); stCheckSolved(stWords[stIndex]);
}
function stSetTilesDraggable(enabled){ document.querySelectorAll('#st .tile').forEach(t=>t.setAttribute('draggable', enabled?'true':'false')); }
function stSetBtnsDisabled(d){ st.reshuffleBtn.disabled=d; st.skipBtn.disabled=d; }
function stMarkFilled(){ [...st.slots.children].forEach(s=>s.classList.toggle('filled', !!s.firstElementChild)); }
function stGetAnswer(){ return [...st.slots.children].map(s=>s.firstElementChild ? s.firstElementChild.dataset.letter : '·').join(''); }
function stComplete(){ return [...st.slots.children].every(s=>!!s.firstElementChild); }

/* CORRECT in small tiles (uiLabel size) */
function stShowCorrect(){
  st.feedback.className='st-result';
  st.feedback.innerHTML='';
  const span=document.createElement('div'); span.className='inlineTiles';
  renderTiles(span, 'CORRECT', 'uiLabel');
  st.feedback.appendChild(span);
}

function stCheckSolved(targetWord){
  if (stPreviewing) return;
  if (!stComplete()){ st.feedback.textContent=''; st.feedback.className='st-result'; return; }
  const guess = stGetAnswer();
  if (guess === targetWord.toUpperCase()){
    stShowCorrect();
    stScore++; stSolved.add(targetWord); stUpdatePills(); setTimeout(stNextWord, 650);
  } else {
    st.feedback.textContent='🧠 Not quite — try swapping some tiles.'; st.feedback.className='st-result bad';
  }
}
function stNextWord(){
  st._removeRefit && st._removeRefit();
  stIndex++; if (stIndex>=stWords.length) return stFinish();
  stUpdatePills(); stBuildWord(stWords[stIndex]);
}
/* COMPLETE + percentage in small tiles (uiLabel size) */
function stFinish(){
  const pct = Math.round((stScore/stWords.length)*100);
  st.summary.style.display='block';

  st.completeText.innerHTML='';
  renderTiles(st.completeText, 'COMPLETE', 'uiLabel');

  st.final.textContent = `You scored ${stScore} of ${stWords.length}.`;

  st.percentText.innerHTML='';
  renderTiles(st.percentText, `${pct}%`, 'uiLabel');
}

st.reshuffleBtn.addEventListener('click', ()=>{
  if (stPreviewing) return;
  [...st.slots.querySelectorAll('.tile')].forEach(t=>st.pool.appendChild(t));
  st.pool.innerHTML=''; const der=stDerange(stTilesOriginal);
  der.forEach((t,i)=> st.pool.appendChild(stMakeTile({...t,index:i,total:der.length})));
  stMarkFilled(); st.feedback.textContent=''; st.feedback.classList.remove('ok','bad'); stSelected=null;
});
st.skipBtn.addEventListener('click', ()=>{ if(!stPreviewing) stNextWord(); });
st.retryBtn.addEventListener('click', ()=>{
  stIndex=0; stScore=0; stSolved.clear(); st.summary.style.display='none';
  stUpdatePills(); stBuildWord(stWords[0]);
});
st.editBtn.addEventListener('click', ()=>{
  document.getElementById('st').style.display='none';
  document.getElementById('setup').style.display='';
  setSectionLabel('Setup');
});
const stBuildBtn = document.getElementById('st-buildCrosswordFromHere');
stBuildBtn.textContent = 'Build Crossword';
st.buildCWHere.addEventListener('click', ()=>{
  const useMode = st.afterUseMode.value;
  let src = useMode==='correct' ? stWords.filter(w=>stSolved.has(w)) : stWords.slice();
  const cap = parseInt(st.afterCap.value,10) || 12;
  src = pickCap(src, cap);  // random
  startCrosswordFlow(src);
});

/* Start Spelling from setup */
startSpellingBtn.addEventListener('click', ()=>{
  const words = parseWords(inputWords.value);
  if (!words.length){ alert('Please enter at least one word.'); return; }
  stWords = words;
  stIndex=0; stScore=0; stSolved.clear();
  document.getElementById('setup').style.display='none';
  document.getElementById('cw').style.display='none';
  document.getElementById('st').style.display='';
  setSectionLabel('Spelling Test'); // section chip uses uiLabel tiles
  stUpdatePills(); stBuildWord(stWords[0]);
});

/* =======================================================================
   CROSSWORD
   ======================================================================= */
const COLOR_WORDS = ["PURPLE","GREEN","BLUE","RED","ORANGE","YELLOW","PINK","BLACK","WHITE","BROWN","GREY"];
let usedColors = new Set();

const cw = {
  root: document.getElementById('cw'),
  board: document.getElementById('cw-board'),
  pool: document.getElementById('cw-pool'),
  feedback: document.getElementById('cw-feedback'),
  progress: document.getElementById('cw-progress'),
  listUI: document.getElementById('cw-listUI'),
  reshuffleBtn: document.getElementById('cw-reshuffleBtn'),
  backBtn: document.getElementById('cw-backToSetup'),
  wordTitle: document.getElementById('cw-wordlist-title'),
};
let wordNodesByIndex = new Map();
let wordListItems = new Map();

renderTiles(cw.wordTitle, 'WORD LIST', 'chipTile'); // tiles heading

function buildCrossword(rawWords, PAD=2, MAX=40){
  const words = rawWords.map(w=>w.toUpperCase()).filter(Boolean);
  words.sort((a,b)=>b.length-a.length);
  const grid=new Map(), placed=[];
  const key=(x,y)=>x+','+y, get=(x,y)=>grid.get(key(x,y)), has=(x,y)=>grid.has(key(x,y)), set=(x,y,ch)=>grid.set(key(x,y),ch);

  function canPlace(word,x,y,dir){
    for(let i=0;i<word.length;i++){
      const gx=x+(dir==='across'?i:0), gy=y+(dir==='down'?i:0);
      if (Math.abs(gx)>MAX || Math.abs(gy)>MAX) return false;
      const curr=get(gx,gy); if (curr && curr!==word[i]) return false;
      const blocked=dir==='across'? [[gx,gy-1],[gx,gy+1]] : [[gx-1,gy],[gx+1,gy]];
      for (const [nx,ny] of blocked){ if (has(nx,ny) && !curr) return false; }
    }
    const ex1x=x+(dir==='across'?-1:0), ex1y=y+(dir==='down'?-1:0);
    const ex2x=x+(dir==='across'?word.length:0), ex2y=y+(dir==='down'?word.length:0);
    if (has(ex1x,ex1y) || has(ex2x,ex2y)) return false;
    return true;
  }
  function place(word,x,y,dir,index){
    for(let i=0;i<word.length;i++){
      const gx=x+(dir==='across'?i:0), gy=y+(dir==='down'?i:0);
      if (!has(gx,gy)) set(gx,gy,word[i]);
    }
    placed.push({word,x,y,dir,index});
  }
  function tryOverlap(word,index){
    const entries=Array.from(grid.entries());
    for (let i=0;i<word.length;i++){
      for (const [k,letter] of entries){
        if (letter!==word[i]) continue;
        const [cx,cy]=k.split(',').map(Number);
        const cand=[{dir:'down',x:cx,y:cy-i},{dir:'across',x:cx-i,y:cy}];
        for (const c of cand){ if (canPlace(word,c.x,c.y,c.dir)){ place(word,c.x,c.y,c.dir,index); return true; } }
      }
    } return false;
  }
  function cellsOf(word,x,y,dir){ const out=[]; for(let i=0;i<word.length;i++){ out.push({x:x+(dir==='across'?i:0), y:y+(dir==='down'?i:0), ch:word[i]}); } return out; }
  function canPlaceSnap(word,x,y,dir,snap){
    const hasS=(xx,yy)=>snap.has(key(xx,yy));
    const getS=(xx,yy)=>snap.get(key(xx,yy));
    for(let i=0;i<word.length;i++){
      const gx=x+(dir==='across'?i:0), gy=y+(dir==='down'?i:0);
      if (Math.abs(gx)>MAX || Math.abs(gy)>MAX) return false;
      const curr=getS(gx,gy); if (curr && curr!==word[i]) return false;
      const blocked=dir==='across'? [[gx,gy-1],[gx,gy+1]] : [[gx-1,gy],[gx+1,gy]];
      for (const [nx,ny] of blocked){ if (hasS(nx,ny) && !curr) return false; }
    }
    const ex1x=x+(dir==='across'?-1:0), ex1y=y+(dir==='down'?-1:0);
    const ex2x=x+(dir==='across'?word.length:0), ex2y=y+(dir==='down'?word.length:0);
    if (snap.has(key(ex1x,ex1y)) || snap.has(key(ex2x,ex2y))) return false;
    return true;
  }
  function placeSnap(word,x,y,dir,snap){ for(let i=0;i<word.length;i++){ const gx=x+(dir==='across'?i:0), gy=y+(dir==='down'?i:0); const k=key(gx,gy); if (!snap.has(k)) snap.set(k,word[i]); } }
  function tryColorBridge(word,index){
    const COLOR_WORDS = ["PURPLE","GREEN","BLUE","RED","ORANGE","YELLOW","PINK","BLACK","WHITE","BROWN","GREY"];
    if (!window.usedColors) window.usedColors = new Set();
    for (const color of COLOR_WORDS){
      if (usedColors.has(color)) continue;
      const snap=new Map(grid); let colorPlaced=false, colorPos=null;
      const entries=Array.from(grid.entries());
      outerColor:
      for (let i=0;i<color.length;i++){
        for (const [k,letter] of entries){
          if (letter!==color[i]) continue;
          const [cx,cy]=k.split(',').map(Number);
          const cand=[{dir:'down',x:cx,y:cy-i},{dir:'across',x:cx-i,y:cy}];
          for (const c of cand){ if (canPlaceSnap(color,c.x,c.y,c.dir,snap)){ placeSnap(color,c.x,c.y,c.dir,snap); colorPlaced=true; colorPos=c; break outerColor; } }
        }
      }
      if (!colorPlaced) continue;
      const colorCells=cellsOf(color,colorPos.x,colorPos.y,colorPos.dir);
      let wordPlaced=false, wordPos=null;
      outerWord:
      for (let wi=0; wi<word.length; wi++){
        for (const {x:cx,y:cy,ch} of colorCells){
          if (word[wi]!==ch) continue;
          const cand=[{dir:'down',x:cx,y:cy-wi},{dir:'across',x:cx-wi,y:cy}];
          for (const c of cand){ if (canPlaceSnap(word,c.x,c.y,c.dir,snap)){ placeSnap(word,c.x,c.y,c.dir,snap); wordPlaced=true; wordPos=c; break outerWord; } }
        }
      }
      if (!wordPlaced) continue;
      grid.clear(); for (const [kk,vv] of snap) grid.set(kk,vv);
      usedColors.add(color);
      place(color,colorPos.x,colorPos.y,colorPos.dir,-1);
      place(word,wordPos.x,wordPos.y,wordPos.dir,index);
      return true;
    }
    return false;
  }

  place(words[0],0,0,'across',0);
  let nextRow=2, nextCol=-2;
  for (let wi=1; wi<words.length; wi++){
    const w=words[wi];
    if (tryOverlap(w,wi)) continue;
    if (tryColorBridge(w,wi)) continue;
    if (wi%2===0){
      let y=nextRow, scans=0;
      rowSearch: while (scans<200){ for(let x=-40;x<=40;x++){ if (grid.has(x+','+y)){ y+=2; scans++; continue rowSearch; } } break; }
      nextRow=y+2; const x=-Math.floor(w.length/2); for(let i=0;i<w.length;i++){ const gx=x+i, gy=y; if (!grid.has(gx+','+gy)) grid.set(gx,gy,w[i]); }
      placed.push({word:w,x,y,dir:'across',index:wi});
    } else {
      let x=nextCol, scans=0;
      colSearch: while (scans<200){ for(let y=-40;y<=40;y++){ if (grid.has(x+','+y)){ x-=2; scans++; continue colSearch; } } break; }
      nextCol=x-2; const y=-Math.floor(w.length/2); for(let i=0;i<w.length;i++){ const gx=x, gy=y+i; if (!grid.has(gx+','+gy)) grid.set(gx,gy,w[i]); }
      placed.push({word:w,x,y,dir:'down',index:wi});
    }
  }
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for (const k of grid.keys()){ const [x,y]=k.split(',').map(Number); if (x<minX)minX=x; if (x>maxX)maxX=x; if (y<minY)minY=y; if (y>maxY)maxY=y; }
  return {grid,placed,bounds:{minX,maxX,minY,maxY},words};
}

function cwUpdateProgress(){ cw.progress.textContent=`Completed: ${document.querySelectorAll('.wordItem.done').length} / ${document.querySelectorAll('.wordItem').length}`; }
function cwBuildChecklist(words){
  cw.listUI.innerHTML=''; wordListItems.clear();
  words.forEach((w,wi)=>{
    const item=document.createElement('div'); item.className='wordItem'; item.dataset.wi=wi;
    item.innerHTML=`<div class="mark">•</div><div class="txt">${w}</div>`;
    cw.listUI.appendChild(item); wordListItems.set(wi,item);
  });
  cwUpdateProgress();
}
function cwMarkDone(wi){
  const el=wordListItems.get(wi);
  if (el && !el.classList.contains('done')){
    el.classList.add('done'); el.querySelector('.mark').textContent='✓';
    cwUpdateProgress();
    if (document.querySelectorAll('.wordItem.done').length === document.querySelectorAll('.wordItem').length){
      cw.feedback.innerHTML='';
      const span=document.createElement('div'); span.className='inlineTiles';
      renderTiles(span, 'WELL  DONE', 'chipTile');
      cw.feedback.appendChild(span);
    }
  }
}
function cwBuildBoard(CW, cluePercent){
  cw.board.innerHTML=''; cw.pool.innerHTML=''; cw.feedback.textContent=''; cw.feedback.className='st-result';
  wordNodesByIndex.clear();

  const {minX,maxX,minY,maxY}=CW.bounds;
  const width=maxX-minX+1; cw.board.style.gridTemplateColumns=`repeat(${width}, auto)`;

  const colorKeySet=new Set();
  for (const p of CW.placed){ if (p.index>=0) continue; for (let i=0;i<p.word.length;i++){ const x=p.x+(p.dir==='across'?i:0), y=p.y+(p.dir==='down'?i:0); colorKeySet.add(x+','+y); } }

  const allRegularKeys=[];
  for (const p of CW.placed){ if (p.index<0) continue;
    for (let i=0;i<p.word.length;i++){ const x=p.x+(p.dir==='across'?i:0), y=p.y+(p.dir==='down'?i:0); allRegularKeys.push(x+','+y); } }
  const giveCount=Math.round(allRegularKeys.length*(cluePercent/100));
  const givenSet=new Set();
  while (givenSet.size<giveCount && givenSet.size<allRegularKeys.length){ givenSet.add(allRegularKeys[Math.floor(Math.random()*allRegularKeys.length)]); }

  const allCells=[];
  for (let y=minY; y<=maxY; y++){
    for (let x=minX; x<=maxX; x++){
      const k=x+','+y; const letter=CW.grid.get(k);
      const cell=document.createElement('div');
      if (!letter){ cell.className='cell block'; }
      else {
        const isColor=colorKeySet.has(k); const given=isColor || givenSet.has(k);
        cell.className='cell '+(given?'given':'slot');
        cell.dataset.letter=letter; cell.dataset.filled=given?'1':'';
        if (given) cell.textContent=letter;

        if (!given){
          cell.addEventListener('dragover', e=>{ e.preventDefault(); cell.classList.add('drop-ok'); });
          cell.addEventListener('dragleave', ()=> cell.classList.remove('drop-ok'));
          cell.addEventListener('drop', e=> cwOnDrop(e, cell));
          cell.addEventListener('click', ()=>{
            if (window.cwSelected){ cwPlaceTileIntoCell(window.cwSelected, cell); window.cwSelected.classList.remove('dragging'); window.cwSelected=null; }
            else if (cell.firstElementChild && cell.firstElementChild.classList.contains('tile')) {
              cw.pool.appendChild(cell.firstElementChild); cell.dataset.filled=''; cwOnGridChange();
            }
          });
        }
      }
      cw.board.appendChild(cell);
      if (letter) allCells.push({node:cell,key:k,target:letter,given:cell.classList.contains('given')});
    }
  }

  // colorful pool tiles
  const letters=[]; for (const c of allCells) if (!c.given) letters.push(c.target);
  letters.sort(()=>Math.random()-.5);
  const totalLetters = letters.length;
  letters.forEach((ch,i)=> cw.pool.appendChild(cwMakeTile(ch,i,totalLetters)));

  // map nodes per word index
  wordNodesByIndex.clear();
  for (const p of CW.placed){
    if (p.index<0) continue;
    const keys=[];
    for (let i=0;i<p.word.length;i++){
      const x=p.x+(p.dir==='across'?i:0), y=p.y+(p.dir==='down'?i:0);
      keys.push(x+','+y);
    }
    const nodes=[]; for (const k of keys){ const cell=allCells.find(c=>c.key===k); if (cell) nodes.push(cell.node); }
    wordNodesByIndex.set(p.index, nodes);
  }
  cwOnGridChange();
}
function cwOnDrop(e,cell){
  e.preventDefault();
  cell.classList.remove('drop-ok');
  const tile=document.querySelector(`#cw .tile.dragging`);
  if (!tile) return;
  cwPlaceTileIntoCell(tile, cell);
}
function cwPlaceTileIntoCell(tile, cell){
  if (!cell.classList.contains('slot')) return;
  const want=cell.dataset.letter, got=tile.dataset.letter;
  if (cell.lastElementChild && cell.lastElementChild.classList.contains('tile')) {
    cw.pool.appendChild(cell.lastElementChild);
  }
  cell.appendChild(tile);
  if (got===want){
    cell.dataset.filled='1';
    cwOnGridChange();
  } else {
    cell.animate([{transform:'translateY(0)'},{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:220});
    setTimeout(()=> cw.pool.appendChild(tile), 140);
  }
}
function cwOnGridChange(){
  for (const [wi, nodes] of wordNodesByIndex.entries()){
    const done = nodes.every(n => n.dataset.filled==='1' || n.classList.contains('given'));
    if (done) cwMarkDone(wi);
  }
}
function cwMakeTile(ch,i,total){
  const t=makeUITile(ch, i, total, '');
  t.setAttribute('draggable','true');
  t.dataset.letter=ch;
  t.addEventListener('dragstart', e=>{
    t.classList.add('dragging');
    try{ e.dataTransfer.setData('text/plain', ch); }catch(_){}
    e.dataTransfer.effectAllowed='move';
  });
  t.addEventListener('dragend', ()=> t.classList.remove('dragging'));
  t.addEventListener('click', ()=>{
    if (window.cwSelected===t){ t.classList.remove('dragging'); window.cwSelected=null; return; }
    if (window.cwSelected) window.cwSelected.classList.remove('dragging');
    window.cwSelected=t; t.classList.add('dragging');
  });
  t.addEventListener('pointerdown', e=>{
    if (e.pointerType==='mouse') return;
    e.preventDefault();
    cwStartTouchDrag(t, e);
  });
  return t;
}

/* touch-drag for crossword */
let cwDrag=null;
function cwStartTouchDrag(tile,e){
  const rect=tile.getBoundingClientRect();
  const ghost=tile.cloneNode(true);
  ghost.style.position='fixed';
  ghost.style.zIndex='9999';
  ghost.style.pointerEvents='none';
  ghost.style.width=rect.width+'px';
  ghost.style.height=rect.height+'px';
  ghost.classList.add('dragging');
  document.body.appendChild(ghost);

  cwDrag={node:tile, ghost, offsetX:e.clientX-rect.left, offsetY:e.clientY-rect.top, lastTarget:null};
  function move(ev){
    ev.preventDefault();
    ghost.style.left=(ev.clientX-cwDrag.offsetX)+'px';
    ghost.style.top=(ev.clientY-cwDrag.offsetY)+'px';
    cwHighlight(ev.clientX,ev.clientY);
  }
  function up(ev){ ev.preventDefault(); cwDropTouch(ev.clientX,ev.clientY); cleanup(); }
  function cancel(){ cwCancelTouch(); cleanup(); }
  function cleanup(){
    document.removeEventListener('pointermove', move, {passive:false});
    document.removeEventListener('pointerup', up, {passive:false});
    document.removeEventListener('pointercancel', cancel);
  }
  document.addEventListener('pointermove', move, {passive:false});
  document.addEventListener('pointerup', up, {passive:false});
  document.addEventListener('pointercancel', cancel);
}
function cwFindSlotAt(x,y){
  let el=document.elementFromPoint(x,y);
  while (el && !el.classList?.contains('slot') && el !== cw.pool && el !== document.body) el=el.parentElement;
  return el && el.classList?.contains('slot') ? el : null;
}
function cwHighlight(x,y){
  const t=cwFindSlotAt(x,y);
  if (cwDrag?.lastTarget?.classList) cwDrag.lastTarget.classList.remove('drop-ok');
  if (t) t.classList.add('drop-ok');
  cwDrag.lastTarget=t;
}
function cwDropTouch(x,y){
  if (!cwDrag) return;
  const cell=cwFindSlotAt(x,y);
  cwDrag.ghost.remove();
  if (cell) cwPlaceTileIntoCell(cwDrag.node, cell);
  cwDrag=null;
}
function cwCancelTouch(){ if (!cwDrag) return; cwDrag.ghost.remove(); cwDrag=null; }

/* Buttons / labels */
document.getElementById('cw-reshuffleBtn').addEventListener('click', ()=>{
  const left=Array.from(cw.pool.children);
  left.sort(()=>Math.random()-.5).forEach(n=>cw.pool.appendChild(n));
});
renderTiles(document.getElementById('cw-wordlist-title'), 'WORD LIST', 'chipTile');

document.getElementById('cw-backToSetup').addEventListener('click', ()=>{
  document.getElementById('cw').style.display='none';
  document.getElementById('setup').style.display='';
  setSectionLabel('Setup');
});

/* Build crossword from setup */
buildCrosswordBtn.addEventListener('click', ()=>{
  const words = parseWords(inputWords.value);
  if (!words.length){ alert('Please enter at least one word.'); return; }
  const cap = parseInt(crossCap.value,10) || 12;
  const chosen = pickCap(words, cap); // random
  startCrosswordFlow(chosen);
});

/* Start crossword flow */
function startCrosswordFlow(words){
  window.usedColors = new Set();
  const clue = parseInt(cluePct.value,10) || 30;
  const CW = buildCrossword(words);
  document.getElementById('setup').style.display='none';
  document.getElementById('st').style.display='none';
  document.getElementById('cw').style.display='';
  setSectionLabel('Crossword'); // section chip (uiLabel size)
  document.getElementById('cw-progress').textContent = `Completed: 0 / ${CW.words.length}`;
  cwBuildBoard(CW, clue);
  cwBuildChecklist(CW.words);
}

/* boot */
setSectionLabel('Setup');
setButtonTileLabel(themeBtn, 'Theme', 'chipTile'); // Theme in tiles
renderTitle(document.getElementById('heroTitle'), 'Spelling Tiles', 'titleTile');
</script>
</body>
</html>
